---
output: html_document
---

## NGINX & Docker-Compose

<strong>NGINX</strong> - An open source web server and reverse proxy technology used for hosting websites and applications

<strong>Docker-Compose</strong> - A technology for enabling docker containers to communicate to each other

In this post, I will go over steps on how to create an encrypt HTTPS traffic that allows users to interact with the Xposome application that is published thru a docker container. To achieve that, we need both NGINX and docker-compose.

Here are the seven steps to set-up NGINX and docker-compose:

1.	Install docker-compose
2.	Build a NGINX image from Docker Hub without the need of installing NGINX software
3.	Dockerize the Xposome application locally or pull the image from Docker Hub
4.	Set up NGINX configuration files (i.e. nginx.conf and default.conf.template)
5.	Create a YAML file for docker-compose (i.e. docker-compose.yml)
6.	Run the docker-compose.yml file
7.	Check to see if the application is running on HTTPS

<br>

#### Step 1: Install docker-compose

Check out how to install Docker-compose <a target="blank" href="https://docs.docker.com/compose/install/">here</a>

To check if docker-compose is installed, 

    docker-compose --version

#### Step 2: Build a docker image for NGINX

A docker image for NGINX can be found on <a target="blank" href="https://hub.docker.com/_/nginx">Docker Hub</a>. You can pull this image without the need to install NGINX software on your local machine.

    docker pull nginx:latest 

To check if the image is built successfully, 

    docker images

Also see this <a target="blank" href="https://hub.docker.com/_/nginx">link</a> on how to use the NGINX image

#### Step 3: Dockerize the Xposome application locally or pull the image from Docker Hub

You can check out this step on my previous post <a href='#dockerize'>here</a> for more details

#### Step 4: Set-up NGINX configuration files

Once the docker images for NGINX and the Xposome application are built successfully, we can start setting up the NGINX configuration files. There are two configuration files for NGINX: <span class="highlight-text">nginx.conf</span> and <span class="highlight-text">default.conf.template</span>. 

The nginx.conf contains the standard configuration for NGINX. Unless you know how to add directives to this configuration file, otherwise I do not recommend making any changes to this file. 

Here is a snapshot of nginx.conf file:

    # For more information on configuration, see:
    #   * Official English Documentation: http://nginx.org/en/docs/
    #   * Official Russian Documentation: http://nginx.org/ru/docs/
    
    user nginx;
    worker_processes auto;
    error_log /var/log/nginx/error.log;
    pid /run/nginx.pid;
    
    # Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
    include /usr/share/nginx/modules/*.conf;
    
    events {
        worker_connections 1024;
    }
    
    mail {
        server_name 155.41.202.164;
        auth_http 155.41.202.164:3838;
    
        proxy_pass_error_message on;
    
        server {
            listen     25;
            protocol   smtp;
            smtp_auth  login plain cram-md5;
        }
    }
    
    http {
        map $http_upgrade $connection_upgrade {
            default upgrade;
            ''      close;
        }
    
        log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for"';
    
        access_log  /var/log/nginx/access.log  main;
    
        sendfile            on;
        tcp_nopush          on;
        tcp_nodelay         on;
        keepalive_timeout   65;
        types_hash_max_size 2048;
    
        # set client body size to 8M #
        client_max_body_size 1000M;
    
        include             /etc/nginx/mime.types;
        default_type        application/octet-stream;
    
        # Load modular configuration files from the /etc/nginx/conf.d directory.
        # See http://nginx.org/en/docs/ngx_core_module.html#include
        # for more information.
        include /etc/nginx/conf.d/*.conf;
    
    }

The default.conf.template contains instructions on how to direct and encrypt any traffics to the Xposome application with HTTPS protocol that is published thru a specific port on the host machine.  

How NGINX, Docker, Shiny talk to each other 

    With NGINX,
    nginx → listens on → port 80 (http) and 443 (https) 

    With Docker,
    Docker → listens on → port 80/443/8080/3838/8000/… 

    With SHINY
    Shiny → listens on localhost (127.0.0.1) → port 3838/8787/4848/… 

In brief, when we run a docker container, we basically expose our shiny application through a port, i.e port 3838, on the localhost. Docker is then listened to this port and redirects the application to a host port, i.e port 7856, on the host machine. If the host machine has a domain, for example, montilab.bu.edu (in my case), then we can navigate to http://montilab.bu.edu:7856 and check to see if the Xposome application is indeed hosted there. 

    Shiny:localhost:3838 → http://montilab.bu.edu:7856  

Nevertheless, we do not want to provide a link to an application with a port number and furthermore the link is not encrypted with HTTPS. Thus, we can use NGINX to create an alias name for the application (for example: https://montilab.bu.edu/Xposome/), and then redirects and encrypts any traffics to the application with HTTPS using <a target="blank" href="https://certbot.eff.org/">Certbot</a>, a free, open source software tool for automatically using Let’s Encrypt certificates on manually-administrated websites to enable HTTPS. As a result, NGINX is served as a reverse proxy for hosting our applications.

    Shiny:localhost:3838 → http://montilab.bu.edu:7856 → https://montilab.bu.edu/Xposome/ 

Here is a snapshot of default.conf.template file:

<a href="www/nginx-conf.png" target="blank"><img class="img-box" src="www/nginx-conf.png"></a>


#### Step 5: Create a docker-compose.yml file

Once we had configured NGINX as a reverse proxy for our application, we can create a docker-compose.yml file that allows communication between the Xposome and NGINX containers.

To enable communication between containers, in the docker-compose.yml file, we must create a service to run the NGINX container and a service to run the Xposome container. Under each service, we need to specify a list of instructions on how a container can be built, for instance, what image is used to build the container, what do we want to name the container, which port do we used to expose the shiny app to Docker, and which port do Docker use to publish the app on a specific port of the host machine, etc.

After we had all of these key components defined, the last step is to make sure that the host port on the docker-compose.yml file matches the port defined in the nginx.conf file.

Here is a snapshot of the docker-compose.yml file:

<a href="www/docker-compose.png" target="blank"><img class="img-box" src="www/docker-compose.png"></a>


#### Step 6: Run the docker-compose file

After we had the docker-compose file and the NGINX configuration files all set up, we can cd to where the docker-compose.yml file is located at and run the following command to fire up all the containers.

    docker-compose up -d
    
    -d is used to run docker compose in detach mode

#### Step 7: Check to make sure the application is running on HTTPS 

If the containers is built without any errors. We can navigate to the alias address of the Xposome application (i.e. https://montilab.bu.edu/Xposome/ in my case) and see if the application is indeed hosted there.

<br><br>





